function []=DrawHedrons(A,b,m,transparency,var)
%
% Функция  DrawHedrons  для каждой нужной строки i 
% системы линейных неравенств  A x >= b
% рисует пересечение множества решений системы
% с плоскостью A(i,:)x=b(i) (i-опору).

   mn=size(b,1);

%   for i=1:mn
   for i=4:mn  % не рисуем опоры, вносимые координатными плоскостями 

      % перейдем из исходной системы координат (0,x1,x2,x3) 
      % в систему внутренних координат (pr,y1,y2) 
      % плоскости i (точнее плоскости A(i,:)x=b(i))
      [pr,At,bt,y1,y2]=ChangeVariable(A,b,i);
   
      % удалим нулевые строки из At 
      % (их могут дать плоскости, параллельные i)
      [At,bt,cnmtyt]=ClearZeroRows(At,bt);
     
      if ~cnmtyt
         continue; % плоскость i не пересекает 
                   % множество решений системы  A x >= b
      end

      % найдем матрицу St граничных интервалов
      [St]=BoundaryIntervals(At,bt);

      % по непустой матрице St составим путь Pt обхода i-опоры
      if size(St,1)>0
         [Pt] = Intervals2Path(St);

         % перепишем матрицу Pt в исходных координатах (x)
%         P=pr+y1*Pt(:,1)+y2*Pt(:,2);
         P=zeros(0,3);
         for k=1:size(Pt,1)
             P=[P ; pr+y1*Pt(k,1)+y2*Pt(k,2) ];
         end

         % назначим прозрачность граней
         %   для реальных - по требованию пользователя,
         %   для остальных - всегда;
         % назначим цвет граней:
         %   для реальных граней - зеленый, 
         %   для граней принудительной обрезки - желтый,
         %   для граней автоматической обрезки - красный
         transp=1;
         c='g';
         if transparency
            transp=0.4; 
         end
         if i>m
            transp=0.4; 
            if var
               c='y';
            else
               c='r';
            end
         end

         % нарисуем i-опору
         fill3(P(:,1),P(:,2),P(:,3),c,'FaceAlpha',transp);

      end

   end    

end